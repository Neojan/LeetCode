# 复杂度
2的x次=N，取对数就是x=logN
分治法是logN，对应快速排序这种需要多次分治的就是NlogN

对数阶常出现于「二分查找」和「分治算法」中，体现 “一分为多” 、“化繁为简” 的算法思想

线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 O(log⁡n) 和 O(n) 。
主流排序算法的时间复杂度都是 O(nlog⁡n) ，例如快速排序、归并排序、堆排序等。

常见时间复杂度从小到大排列有 O(1) , O(log⁡n) , O(n) , O(nlogn) , O(n2) , O(2n) , O(n!) 。

# 数组

## 一维数组前缀和

顾名思义：就是建立数组时，构建每一项都是前面所有项之和的方法

## 二维数组前缀和

即求面积类似，4块正方形，增加一块，和=大的-小的-小的+重复的+新增的

## 差分数组

即每一项存储与前一项的差值

更新 d[i] += val, d[j+1] -= val,这里是【i,j】注意边界开闭,更新函数可以固定，根据传参进行开闭处理

# 链表

## 有序链表合并
可以创建虚拟头节点，方便操作
ListNode *dummpy = new dummpy(-1);

## 分割一个链表成两个
注意不要忘了拆分原先的链表，否则指向会乱套

## 合并 k 个有序链表

这里用到优先级队列（二叉堆）。
方法很巧妙，先将所有头节点放入优先级队列（小根堆），然后取出一个值（即为最小值），然后该链指向next并加入到队列中，然后再从队列取出一个值（也是最小值），直到队列不为空为止

## 倒数第k个
倒数第k个 = 正数 n-k+1

# 双指针技巧
只要数组有序，就应该想到双指针技巧

## 快慢/左右指针
所谓左右指针，就是两个指针相向⽽⾏或者相背⽽⾏；⽽所谓快慢指针，就是两个指针同向⽽⾏，⼀快⼀ 慢。比如中心向两边的回文串，比如反转字符串等。
快指针比慢指针多走一步，可以计算链表终点，环形链表等.有序数组/链表中去重.

## 哈希
比如160-相交链表题目

# 滑动窗口

## 口诀
滑动窗口防滑记
链表子串数组题，用双指针别犹豫，
双指针家三兄弟，各个都是万人迷。
快慢指针最神奇，链表操作无压力。
归并排序找中点，链表成环搞判定。
左右指针最常见，左右两端相向行。
反转数组要靠它，二分搜索是弟弟。
滑动窗口老猛男，子串问题全靠它。
左右指针滑窗口，一前一后齐头进。

## 代码
```cpp

/* 滑动窗⼝算法框架 */
void slidingWindow(string s) {
 unordered_map<char, int> window;
 
 int left = 0, right = 0;
 while (right < s.size()) {
 // c 是将移⼊窗⼝的字符
 char c = s[right];
 // 增⼤窗⼝
 right++;
 // 进⾏窗⼝内数据的⼀系列更新
 ...
 /*** debug 输出的位置 ***/
 printf("window: [%d, %d)\n", left, right);
 /********************/
 
 // 判断左侧窗⼝是否要收缩
 // 如right-left >= xx.length()
 while (window needs shrink) {
 // d 是将移出窗⼝的字符
 char d = s[left];
 // 缩⼩窗⼝
 left++;
 // 进⾏窗⼝内数据的⼀系列更新
 ...
 }
 }
}
```

# 二分查找
以下是通用方法，左闭右闭 [left, right]

```cpp
// 寻找一个值
int binary_search(vector <int> s, int d)
{
    int mid = 0, left = 0, right = s.size()-1;
    while(left <= right)
    {
        mid = left + (right - left) / 2;
        if (s[mid] < d)
        {
            left = mid + 1;
        }
        else if (s[mid] > d)
        {
            right = mid - 1;
        }
        else if (s[mid] == d)
        {
            return mid;
        }
    }
    return -1;
}

// 寻中左边界
int binary_search_left_bound(vector<int> s, int d)
{
    int mid = 0, left = 0, right = s.size() - 1;
    while (left <= right)
    {
        mid = left + (right - left) / 2;
        if (s[mid] < d)
        {
            left = mid + 1;
        }
        else if (s[mid] > d)
        {
            right = mid - 1;
        }
        else if (s[mid] == d)
        {
            right = mid - 1;
        }
    }
    cout << left << "," << s.size()<< endl;
    if (left == s.size())
        return -1;
    
    return s[left]==d ? left : -1;
}

// 寻中右边界
int binary_search_right_bound(vector<int> s, int d)
{
    int mid = 0, left = 0, right = s.size() - 1;
    while (left <= right)
    {
        mid = left + (right - left) / 2;
        if (s[mid] < d)
        {
            left = mid + 1;
        }
        else if (s[mid] > d)
        {
            right = mid - 1;
        }
        else if (s[mid] == d)
        {
            left = mid + 1;
        }
    }
    cout << left << "," << s.size() << endl;
    if (left -1 < 0)
        return -1;

    return s[left - 1] == d ? (left - 1) : -1;
}

int main(void)
{
    vector<int> s1{0,1,2,3,4,5,6,7};
    int pos = binary_search(s1, 3);
    vector<int> s2{1, 2, 3, 3, 3, 4, 6, 7};

    pos = binary_search_left_bound(s2, 0);
    pos = binary_search_left_bound(s2, 1);
    pos = binary_search_left_bound(s2, 8);
    pos = binary_search_left_bound(s2, 3);
    pos = binary_search_right_bound(s2, 3);
    pos = binary_search_right_bound(s2, 1);
    cout << pos << endl;

    return 0;
}
```


# 动态规划
Dynamic Programming
递归：自顶向下； 动态规划，自底向上

解题思路：
明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。
另外剪枝考虑备忘录memo
- 动态规划问题，具有「最优子结构」。要符合「最优子结构」，子问题间必须互相独立。
最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。
- 动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。
- 找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。
- 重叠子问题：最简单粗暴的方式就是画图，把递归树画出来，看看有没有重复的节点。但稍加思考就可以知道，其实根本没必要画图，可以通过递归框架直接判断是否存在重叠子问题。

动态规划最难的就是写出状态迁移方程，例如斐波那契的方程
f(n) = 1, n = 1, n = 2
f(n) = f(n-1) + f(n-2), n > 2

## 数零钱问题
dp(n) n是总额，dp(n) 是所需硬币个数，则
dp(n) = 0, n = 0;
dp(n) = -1, n < 0;
dp(n) = min(dp(n), dp(n-coion)+1), n > 0; 
即dp(n) = dp(n-coins) + 1 表示再加一枚硬币
```cpp
int coinChange(vector<int> &coins, int amount)
{
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector<int> dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    for (int i = 0; i < dp.size(); i++)
    {
        // 内层 for 在求所有子问题 + 1 的最小值
        for (int coin : coins)
        {
            // 子问题无解，跳过
            if (i - coin < 0)
                continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
            cout << i << ":" << dp[i] << endl;
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```

## 最长递增子序列问题
- 最长递增子序列（Longest Increasing Subsequence，简写 LIS）是非常经典的一个算法问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)
```java
int lengthOfLIS(int[] nums) {
    // 定义：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
    int[] dp = new int[nums.length];
    // base case：dp 数组全都初始化为 1
    Arrays.fill(dp, 1);
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) 
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }

    int res = 0;
    for (int i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
```

## 最小路径和
给你输入一个二维数组grid，其中的元素都是非负整数，现在你站在左上角，只能向右或者向下移动，需要到达右下角。现在请你计算，经过的路径和最小是多少？

```cpp
// 二维数组初始化
vector<vector<int> > grid = vector<vector<int> >(2, vector<int>(3)) = { {1, 2, 3}, {4, 5, 6} };

int minPathSum(vector<vector<int>> &grid)
{
    int                 m = grid.size();
    int                 n = grid[0].size();
    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));

    //base case
    dp[0][0] = grid[0][0];
    for (int i = 1; i < m; i++)
    {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    for (int j = 1; j < n; j++)
    {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }

    for (int i = 1; i < m; i++)
    {
        for (int j = 1; j < n; j++)
        {
            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
        }
    }
    return dp[m - 1][n - 1];
}
```

## 最大子数组和问题
求出数组中最大的子数组和
```cpp
int maxSubArray(int[] nums) {
    int n = nums.length;
    if (n == 0) return 0;
    // base case
    int dp_0 = nums[0];
    int dp_1 = 0, res = dp_0;

    for (int i = 1; i < n; i++) {
        // dp[i] = max(nums[i], nums[i] + dp[i-1])
        dp_1 = Math.max(nums[i], nums[i] + dp_0);
        dp_0 = dp_1;
        // 顺便计算最大的结果
        res = Math.max(res, dp_1);
    }

    return res;
}
```

## 编辑距离
```java
int minDistance(String s1， String s2) 
{
    int m = s1. length(),n = s2.length();
    int[][] dp = new int[m + 1][n + 1];
    // base case
    for (int i = 1; i <= m; i++)
        dp[i][0] = i;
    for (int j = 1; j <= n; j++)
        dp[0][j] = j;
    // 自底向上求解
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            if (s1.charAt(i-1) == s2.charAt(j-1))
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = min(
                    dp[i - 1][j] + 1,
                    dp[i][j - 1] + 1,
                    dp[i - 1][j - 1] + 1
                    );
    // 储存着整个 s1 和 s2 的最小编辑距离
    return dp[m][n];
}
int min(int a, int b, int c)
{
    return Math.min(a，Math.min(b，c));
}
```