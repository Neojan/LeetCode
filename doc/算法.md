# 复杂度
2的x次=N，取对数就是x=logN
分治法是logN，对应快速排序这种需要多次分治的就是NlogN

对数阶常出现于「二分查找」和「分治算法」中，体现 “一分为多” 、“化繁为简” 的算法思想

线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 O(log⁡n) 和 O(n) 。
主流排序算法的时间复杂度都是 O(nlog⁡n) ，例如快速排序、归并排序、堆排序等。

常见时间复杂度从小到大排列有 O(1) , O(log⁡n) , O(n) , O(nlogn) , O(n2) , O(2n) , O(n!) 。

# 数组

## 一维数组前缀和

顾名思义：就是建立数组时，构建每一项都是前面所有项之和的方法

## 二维数组前缀和

即求面积类似，4块正方形，增加一块，和=大的-小的-小的+重复的+新增的

## 差分数组

即每一项存储与前一项的差值

更新 d[i] += val, d[j+1] -= val,这里是【i,j】注意边界开闭,更新函数可以固定，根据传参进行开闭处理

# 链表

## 有序链表合并
可以创建虚拟头节点，方便操作
ListNode *dummpy = new dummpy(-1);

## 分割一个链表成两个
注意不要忘了拆分原先的链表，否则指向会乱套

## 合并 k 个有序链表

这里用到优先级队列（二叉堆）。
方法很巧妙，先将所有头节点放入优先级队列（小根堆），然后取出一个值（即为最小值），然后该链指向next并加入到队列中，然后再从队列取出一个值（也是最小值），直到队列不为空为止

## 倒数第k个
倒数第k个 = 正数 n-k+1

# 双指针技巧
只要数组有序，就应该想到双指针技巧

## 快慢/左右指针
所谓左右指针，就是两个指针相向⽽⾏或者相背⽽⾏；⽽所谓快慢指针，就是两个指针同向⽽⾏，⼀快⼀ 慢。比如中心向两边的回文串，比如反转字符串等。
快指针比慢指针多走一步，可以计算链表终点，环形链表等.有序数组/链表中去重.

## 哈希
比如160-相交链表题目

# 滑动窗口

## 口诀
滑动窗口防滑记
链表子串数组题，用双指针别犹豫，
双指针家三兄弟，各个都是万人迷。
快慢指针最神奇，链表操作无压力。
归并排序找中点，链表成环搞判定。
左右指针最常见，左右两端相向行。
反转数组要靠它，二分搜索是弟弟。
滑动窗口老猛男，子串问题全靠它。
左右指针滑窗口，一前一后齐头进。

## 代码
```cpp

/* 滑动窗⼝算法框架 */
void slidingWindow(string s) {
 unordered_map<char, int> window;
 
 int left = 0, right = 0;
 while (right < s.size()) {
 // c 是将移⼊窗⼝的字符
 char c = s[right];
 // 增⼤窗⼝
 right++;
 // 进⾏窗⼝内数据的⼀系列更新
 ...
 /*** debug 输出的位置 ***/
 printf("window: [%d, %d)\n", left, right);
 /********************/
 
 // 判断左侧窗⼝是否要收缩
 // 如right-left >= xx.length()
 while (window needs shrink) {
 // d 是将移出窗⼝的字符
 char d = s[left];
 // 缩⼩窗⼝
 left++;
 // 进⾏窗⼝内数据的⼀系列更新
 ...
 }
 }
}
```

# 二分查找
以下是通用方法，左闭右闭 [left, right]

```cpp
// 寻找一个值
int binary_search(vector <int> s, int d)
{
    int mid = 0, left = 0, right = s.size()-1;
    while(left <= right)
    {
        mid = left + (right - left) / 2;
        if (s[mid] < d)
        {
            left = mid + 1;
        }
        else if (s[mid] > d)
        {
            right = mid - 1;
        }
        else if (s[mid] == d)
        {
            return mid;
        }
    }
    return -1;
}

// 寻中左边界
int binary_search_left_bound(vector<int> s, int d)
{
    int mid = 0, left = 0, right = s.size() - 1;
    while (left <= right)
    {
        mid = left + (right - left) / 2;
        if (s[mid] < d)
        {
            left = mid + 1;
        }
        else if (s[mid] > d)
        {
            right = mid - 1;
        }
        else if (s[mid] == d)
        {
            right = mid - 1;
        }
    }
    cout << left << "," << s.size()<< endl;
    if (left == s.size())
        return -1;
    
    return s[left]==d ? left : -1;
}

// 寻中右边界
int binary_search_right_bound(vector<int> s, int d)
{
    int mid = 0, left = 0, right = s.size() - 1;
    while (left <= right)
    {
        mid = left + (right - left) / 2;
        if (s[mid] < d)
        {
            left = mid + 1;
        }
        else if (s[mid] > d)
        {
            right = mid - 1;
        }
        else if (s[mid] == d)
        {
            left = mid + 1;
        }
    }
    cout << left << "," << s.size() << endl;
    if (left -1 < 0)
        return -1;

    return s[left - 1] == d ? (left - 1) : -1;
}

int main(void)
{
    vector<int> s1{0,1,2,3,4,5,6,7};
    int pos = binary_search(s1, 3);
    vector<int> s2{1, 2, 3, 3, 3, 4, 6, 7};

    pos = binary_search_left_bound(s2, 0);
    pos = binary_search_left_bound(s2, 1);
    pos = binary_search_left_bound(s2, 8);
    pos = binary_search_left_bound(s2, 3);
    pos = binary_search_right_bound(s2, 3);
    pos = binary_search_right_bound(s2, 1);
    cout << pos << endl;

    return 0;
}
```

