# 复杂度
2的x次=N，取对数就是x=logN
分治法是logN，对应快速排序这种需要多次分治的就是NlogN

对数阶常出现于「二分查找」和「分治算法」中，体现 “一分为多” 、“化繁为简” 的算法思想

线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 O(log⁡n) 和 O(n) 。
主流排序算法的时间复杂度都是 O(nlog⁡n) ，例如快速排序、归并排序、堆排序等。

常见时间复杂度从小到大排列有 O(1) , O(log⁡n) , O(n) , O(nlogn) , O(n2) , O(2n) , O(n!) 。

# 数组

## 一维数组前缀和

顾名思义：就是建立数组时，构建每一项都是前面所有项之和的方法

## 二维数组前缀和

即求面积类似，4块正方形，增加一块，和=大的-小的-小的+重复的+新增的

## 差分数组

即每一项存储与前一项的差值

更新 d[i] += val, d[j+1] -= val,这里是【i,j】注意边界开闭,更新函数可以固定，根据传参进行开闭处理

# 链表

## 有序链表合并
可以创建虚拟头节点，方便操作
ListNode *dummpy = new dummpy(-1);

## 分割一个链表成两个
注意不要忘了拆分原先的链表，否则指向会乱套

## 合并 k 个有序链表

这里用到优先级队列（二叉堆）。
方法很巧妙，先将所有头节点放入优先级队列（小根堆），然后取出一个值（即为最小值），然后该链指向next并加入到队列中，然后再从队列取出一个值（也是最小值），直到队列不为空为止

## 倒数第k个
倒数第k个 = 正数 n-k+1

# 双指针技巧
只要数组有序，就应该想到双指针技巧

## 快慢/左右指针
所谓左右指针，就是两个指针相向⽽⾏或者相背⽽⾏；⽽所谓快慢指针，就是两个指针同向⽽⾏，⼀快⼀ 慢。
快指针比慢指针多走一步，可以计算链表终点，环形链表等

## 哈希
### unordered_set：无序 set 容器
唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。
方法：insert,emplace(插入),find,clear,begin,end,count(key),size
比如160-相交链表题目

### unordered_map:无序 map 容器
#include <unordered_map>
unordered_map 容器底层采用的是哈希表存储结构
unordered_map<int, int> vistor
主要方法:
查找：find(key)(如果没找到，返回vistor.end())
查找个数：count(key)
插入：vistor[key] = value;
插入：emplace(key,value)
比如1-两数之和题目
